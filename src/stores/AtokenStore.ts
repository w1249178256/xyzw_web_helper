import { useLocalStorage } from "@vueuse/core";
import { defineStore } from "pinia";
import { computed, ref } from "vue";
import { g_utils, ProtoMsg } from "@/utils/bonProtocol";
import { gameLogger, tokenLogger, wsLogger } from "@/utils/logger";
import { XyzwWebSocketClient } from "@/utils/xyzwWebSocket";

import { emitPlus } from "./events/index.js";
import useIndexedDB from "@/hooks/useIndexedDB";
import { transformToken } from "@/utils/token";
import { generateRandomSeed } from "@/utils/randomSeed";

const { getArrayBuffer } = useIndexedDB();

declare interface TokenData {
  id: string;
  name: string;
  token: string; // åŸå§‹Base64 token
  wsUrl: string | null; // å¯é€‰çš„è‡ªå®šä¹‰WebSocket URL
  server: string;
  remark?: string; // å¤‡æ³¨ä¿¡æ¯
  importMethod?: 'manual' | 'bin' | 'url' | 'wxQrcode'; // å¯¼å…¥æ–¹å¼ï¼šmanualï¼ˆæ‰‹åŠ¨ï¼‰ã€binæ–‡ä»¶ã€urlé“¾æ¥æˆ–å¾®ä¿¡äºŒç»´ç 
  sourceUrl?: string; // å½“importMethodä¸ºurlæ—¶ï¼Œå­˜å‚¨urlé“¾æ¥
  upgradedToPermanent?: boolean; // æ˜¯å¦å‡çº§ä¸ºé•¿æœŸæœ‰æ•ˆ
  upgradedAt?: string; // å‡çº§æ—¶é—´
  updatedAt?: string; // æ›´æ–°æ—¶é—´
  base64Token?: string; // å­˜å‚¨åŸå§‹çš„Base64 tokenç”¨äºé‡è¿
  originalStorageKey?: string; // åŸå§‹å­˜å‚¨åˆ°IndexedDBæ—¶ä½¿ç”¨çš„keyï¼Œå¯¹äºbin/wxQrcodeå¯¼å…¥æ˜¯MD5å“ˆå¸Œå€¼
}

declare interface WebSocketConnection {
  status: "connecting" | "connected" | "disconnected" | "error";
  client: XyzwWebSocketClient | null;
  lastError: { timestamp: string; error: string } | null;
  tokenId: string;
  sessionId: string;
  createdAt: string;
  lastMessageAt: string | null;
  randomSeedSynced?: boolean;
  lastRandomSeedSource?: number | null;
  lastRandomSeed?: number | null;
}

declare type WebCtx = Record<string, Partial<WebSocketConnection>>;

declare interface ConnectLock {
  tokenId: string;
  operation: "connect" | "disconnect";
  timestamp: number;
  sessionId: string;
}
declare type LockCtx = Record<string, Partial<ConnectLock>>;

export const gameTokens = useLocalStorage<TokenData[]>("gameTokens", []);
export const hasTokens = computed(() => gameTokens.value.length > 0);
export const selectedTokenId = useLocalStorage("selectedTokenId", "");
export const selectedToken = computed(() => {
  return gameTokens.value?.find((token) => token.id === selectedTokenId.value);
});
export const selectedRoleInfo = useLocalStorage<any>("selectedRoleInfo", null);

// è·¨æ ‡ç­¾é¡µè¿æ¥åè°ƒ
const activeConnections = useLocalStorage("activeConnections", {});

/**
 * é‡æ„åçš„Tokenç®¡ç†å­˜å‚¨
 * ä»¥åç§°-tokenåˆ—è¡¨å½¢å¼ç®¡ç†å¤šä¸ªæ¸¸æˆè§’è‰²
 */
export const useTokenStore = defineStore("tokens", () => {
  const wsConnections = ref<WebCtx>({}); // WebSocketè¿æ¥çŠ¶æ€
  const connectionLocks = ref<LockCtx>({}); // è¿æ¥æ“ä½œé”ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶

  // è¿æ¥é™æµç›¸å…³çŠ¶æ€
  const connectionQueue = ref<string[]>([]); // è¿æ¥è¯·æ±‚é˜Ÿåˆ—
  const activeConnectionCount = ref(0); // å½“å‰æ´»è·ƒè¿æ¥æ•°
  const maxConcurrentConnections = ref(5); // æœ€å¤§å¹¶å‘è¿æ¥æ•°ï¼ˆæœ€å¤šä¿æŒ5ä¸ªè¿æ¥ï¼‰
  const connectionDelay = ref(500); // è¿æ¥é—´éš”æ—¶é—´(ms)
  const connectionQueuePositions = ref<Record<string, number>>({}); // æ¯ä¸ªtokenåœ¨é˜Ÿåˆ—ä¸­çš„ä½ç½®
  const connectionQueueTimestamps = ref<Record<string, number>>({}); // æ¯ä¸ªtokenåŠ å…¥é˜Ÿåˆ—çš„æ—¶é—´

  // ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€è·Ÿè¸ª
  const runningTasksCount = ref(0); // å½“å‰è¿è¡Œçš„ä»»åŠ¡æ•°é‡
  const scheduledTasksQueue = ref<number>(0); // æ’é˜Ÿçš„å®šæ—¶ä»»åŠ¡æ•°é‡
  const isTasksRunning = ref(false); // æ˜¯å¦æœ‰ä»»åŠ¡æ­£åœ¨æ‰§è¡Œ
  const shouldCloseConnectionsAfterTasks = ref(false); // ä»»åŠ¡å®Œæˆåæ˜¯å¦å…³é—­è¿æ¥

  // è®¡ç®—å±æ€§ï¼šè·å–æ’é˜Ÿä¸­çš„tokenåˆ—è¡¨
  const queuedTokens = computed(() => {
    return [...connectionQueue.value];
  });

  // è®¡ç®—å±æ€§ï¼šè·å–é¢„è®¡ç­‰å¾…æ—¶é—´
  const getEstimatedWaitTime = (tokenId: string) => {
    const position = connectionQueuePositions.value[tokenId];
    if (position === undefined || position < 0) return 0;

    // é¢„è®¡ç­‰å¾…æ—¶é—´ = (å½“å‰æ´»è·ƒè¿æ¥æ•° + é˜Ÿåˆ—ä½ç½®) * è¿æ¥é—´éš”æ—¶é—´
    return (activeConnectionCount.value + position) * connectionDelay.value;
  };

  // æ¸¸æˆæ•°æ®å­˜å‚¨
  const gameData = ref({
    roleInfo: null,
    legionInfo: null,
    commonActivityInfo: null, // æ¶ˆè€—æ´»åŠ¨è¿›åº¦
    bossTowerInfo: null, //å®åº“
    evoTowerInfo: null, //æ€ªå¼‚å¡”
    presetTeam: null,
    battleVersion: null as number | null, // æˆ˜æ–—ç‰ˆæœ¬å·
    studyStatus: {
      isAnswering: false,
      questionCount: 0,
      answeredCount: 0,
      status: "", // '', 'starting', 'answering', 'claiming_rewards', 'completed'
      timestamp: null,
    },
    lastUpdated: null as string | null,
  });

  // è·å–å½“å‰é€‰ä¸­tokençš„è§’è‰²ä¿¡æ¯
  const selectedTokenRoleInfo = computed(() => {
    return gameData.value.roleInfo;
  });

  const readStatisticsValue = (stats: any, key: string) => {
    if (!stats) return undefined;
    try {
      if (typeof stats.get === "function") {
        return stats.get(key);
      }
      if (Object.prototype.hasOwnProperty.call(stats, key)) {
        return stats[key];
      }
    } catch (error) {
      gameLogger.warn("è¯»å–ç»Ÿè®¡æ•°æ®å¤±è´¥:", error);
    }
    return undefined;
  };

  const extractLastLoginTimestamp = (payload: any) => {
    if (!payload) return null;

    const candidateSources = [
      payload?.role?.statistics,
      payload?.statistics,
      payload?.role?.statisticsTime,
      payload?.statisticsTime,
    ];

    const candidateKeys = [
      "last:login:time",
      "lastLoginTime",
      "last_login_time",
    ];

    for (const stats of candidateSources) {
      if (!stats) continue;
      for (const key of candidateKeys) {
        const value = readStatisticsValue(stats, key);
        if (value !== undefined && value !== null) {
          const numeric = Number(value);
          if (!Number.isNaN(numeric) && numeric > 0) {
            return numeric;
          }
        }
      }
    }
    return null;
  };

  const syncRandomSeedFromStatistics = (
    tokenId: string,
    rolePayload: any,
    client: XyzwWebSocketClient | null,
  ) => {
    if (!client) return;
    const connection = wsConnections.value[tokenId];
    if (!connection || connection.status !== "connected") {
      return;
    }

    const lastLoginTime = extractLastLoginTimestamp(rolePayload);
    if (!lastLoginTime) {
      return;
    }

    if (
      connection.randomSeedSynced &&
      connection.lastRandomSeedSource === lastLoginTime
    ) {
      return;
    }

    const randomSeed = generateRandomSeed(lastLoginTime);

    try {
      client.send("system_custom", {
        key: "randomSeed",
        value: randomSeed,
      });
      connection.randomSeedSynced = true;
      connection.lastRandomSeedSource = lastLoginTime;
      connection.lastRandomSeed = randomSeed;
      wsLogger.info(`åŒæ­¥ randomSeed [${tokenId}]`, {
        lastLoginTime,
        randomSeed,
      });
    } catch (error) {
      wsLogger.error(`å‘é€ randomSeed å¤±è´¥ [${tokenId}]`, error);
    }
  };

  // Tokenç®¡ç†
  const addToken = (tokenData: TokenData) => {
    const newToken = {
      id: "token_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9),
      name: tokenData.name,
      token: tokenData.token, // ä¿å­˜åŸå§‹Base64 token
      wsUrl: tokenData.wsUrl || null, // å¯é€‰çš„è‡ªå®šä¹‰WebSocket URL
      server: tokenData.server || "",
      remark: tokenData.remark || "", // å¤‡æ³¨ä¿¡æ¯
      level: tokenData.level || 1,
      profession: tokenData.profession || "",
      createdAt: new Date().toISOString(),
      lastUsed: new Date().toISOString(),
      isActive: true,
      // URLè·å–ç›¸å…³ä¿¡æ¯
      sourceUrl: tokenData.sourceUrl || null, // Tokenæ¥æºURLï¼ˆç”¨äºåˆ·æ–°ï¼‰
      importMethod: tokenData.importMethod || "manual", // å¯¼å…¥æ–¹å¼ï¼šmanual æˆ– url
      base64Token: tokenData.token, // å­˜å‚¨åŸå§‹çš„Base64 tokenç”¨äºé‡è¿
      originalStorageKey: tokenData.originalStorageKey, // ä¿å­˜åŸå§‹å­˜å‚¨åˆ°IndexedDBæ—¶ä½¿ç”¨çš„key
    };

    gameTokens.value.push(newToken);
    return newToken;
  };

  const updateToken = (tokenId: string, updates: Partial<TokenData>) => {
    const index = gameTokens.value.findIndex((token) => token.id === tokenId);
    if (index !== -1) {
      gameTokens.value[index] = {
        ...gameTokens.value[index],
        ...updates,
        updatedAt: new Date().toISOString(),
      };
      return true;
    }
    return false;
  };

  const removeToken = (tokenId: string) => {
    gameTokens.value = gameTokens.value.filter((token) => token.id !== tokenId);

    // å…³é—­å¯¹åº”çš„WebSocketè¿æ¥
    if (wsConnections.value[tokenId]) {
      closeWebSocketConnection(tokenId);
    }

    // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­tokenï¼Œæ¸…é™¤é€‰ä¸­çŠ¶æ€
    if (selectedTokenId.value === tokenId) {
      selectedTokenId.value = null;
    }

    return true;
  };

  const selectToken = (tokenId: string, forceReconnect = false) => {
    const token = gameTokens.value.find((t) => t.id === tokenId);
    if (!token) {
      return null;
    }

    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯å½“å‰é€‰ä¸­çš„token
    const isAlreadySelected = selectedTokenId.value === tokenId;
    const existingConnection = wsConnections.value[tokenId];
    const isConnected = existingConnection?.status === "connected";
    const isConnecting = existingConnection?.status === "connecting";

    tokenLogger.debug(`é€‰æ‹©Token: ${tokenId}`, {
      isAlreadySelected,
      isConnected,
      isConnecting,
      forceReconnect,
    });

    // æ›´æ–°é€‰ä¸­çŠ¶æ€
    selectedTokenId.value = tokenId;

    // æ›´æ–°æœ€åä½¿ç”¨æ—¶é—´
    updateToken(tokenId, { lastUsed: new Date().toISOString() });
    //é¿å…ç‚¹å‡»æ–­å¼€é“¾æ¥
    if (isConnected) {
      return token;
    }
    // æ™ºèƒ½è¿æ¥åˆ¤æ–­
    const shouldCreateConnection =
      forceReconnect || // å¼ºåˆ¶é‡è¿
      !isAlreadySelected || // é¦–æ¬¡é€‰æ‹©æ­¤token
      !existingConnection || // æ²¡æœ‰ç°æœ‰è¿æ¥
      existingConnection.status === "disconnected" || // è¿æ¥å·²æ–­å¼€
      existingConnection.status === "error"; // è¿æ¥å‡ºé”™

    if (shouldCreateConnection) {
      if (isAlreadySelected && !forceReconnect) {
        wsLogger.info(`Tokenå·²é€‰ä¸­ä½†æ— è¿æ¥ï¼Œåˆ›å»ºæ–°è¿æ¥: ${tokenId}`);
      } else if (!isAlreadySelected) {
        wsLogger.info(`åˆ‡æ¢åˆ°æ–°Tokenï¼Œåˆ›å»ºè¿æ¥: ${tokenId}`);
      } else if (forceReconnect) {
        wsLogger.info(`å¼ºåˆ¶é‡è¿Token: ${tokenId}`);
      }

      // åˆ›å»ºWebSocketè¿æ¥
      createWebSocketConnection(tokenId, token.token, token.wsUrl);
    } else {
      if (isConnected) {
        wsLogger.debug(`Tokenå·²è¿æ¥ï¼Œè·³è¿‡è¿æ¥åˆ›å»º: ${tokenId}`);
      } else if (isConnecting) {
        wsLogger.debug(`Tokenè¿æ¥ä¸­ï¼Œè·³è¿‡è¿æ¥åˆ›å»º: ${tokenId}`);
      } else {
        wsLogger.debug(`Tokenå·²é€‰ä¸­ä¸”æœ‰è¿æ¥ï¼Œè·³è¿‡è¿æ¥åˆ›å»º: ${tokenId}`);
      }
    }

    return token;
  };

  // æ¸¸æˆæ¶ˆæ¯å¤„ç†
  const handleGameMessage = async (
    tokenId: string,
    message: ProtoMsg,
    client: any,
  ) => {
    try {
      if (!message) {
        gameLogger.warn(`æ¶ˆæ¯å¤„ç†è·³è¿‡ [${tokenId}]: æ— æ•ˆæ¶ˆæ¯`);
        return;
      }
      if (message.error) {
        const errText = String(message.error).toLowerCase();
        gameLogger.warn(`æ¶ˆæ¯å¤„ç†è·³è¿‡ [${tokenId}]:`, message.error);

        // ç‰¹æ®Šå¤„ç†internal error
        if (errText.includes("internal error")) {
          gameLogger.error(`ğŸš¨ æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ [${tokenId}]: è¿™é€šå¸¸è¡¨ç¤ºæœåŠ¡å™¨ç«¯å‡ºç°é—®é¢˜`);
          gameLogger.error(`å¯èƒ½çš„åŸå› :`, {
            'æœåŠ¡å™¨è´Ÿè½½è¿‡é«˜': 'è¯·ç¨åå†è¯•',
            'æœåŠ¡å™¨ç»´æŠ¤ä¸­': 'æ£€æŸ¥æ¸¸æˆå®˜æ–¹å…¬å‘Š',
            'Tokené—®é¢˜': 'å°è¯•é‡æ–°å¯¼å…¥Token',
            'ç½‘ç»œé—®é¢˜': 'æ£€æŸ¥ç½‘ç»œè¿æ¥'
          });

          // è®¾ç½®è¿æ¥çŠ¶æ€ä¸ºé”™è¯¯
          const conn = wsConnections.value[tokenId];
          if (conn) {
            conn.status = "error";
            conn.lastError = {
              timestamp: new Date().toISOString(),
              error: "internal error",
              description: "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œå¯èƒ½æ˜¯æœåŠ¡å™¨è¿‡è½½æˆ–ç»´æŠ¤ä¸­"
            };
          }
          return;
        }

        if (errText.includes("token") && errText.includes("expired")) {
          const conn = wsConnections.value[tokenId];
          if (conn) {
            conn.status = "error";
            conn.lastError = {
              timestamp: new Date().toISOString(),
              error: "token expired",
            };
          }

          const gameToken = gameTokens.value.find((t) => t.id === tokenId);
          console.log(gameToken);
          if (gameToken) {
            if (gameToken.importMethod === "url" && gameToken.sourceUrl) {
              // URLå½¢å¼tokenåˆ·æ–°
              try {
                const response = await fetch(gameToken.sourceUrl);
                if (response.ok) {
                  const data = await response.json();
                  if (data.token) {
                    // ç›´æ¥ä½¿ç”¨è¿”å›çš„tokenï¼Œæ— éœ€transformToken
                    updateToken(tokenId, { ...gameToken, token: data.token });
                    console.log("ä»URLè·å–tokenæˆåŠŸ:", gameToken.name);
                  }
                }
              } catch (error) {
                console.error("ä»URLè·å–tokenå¤±è´¥:", error);
              }
            } else if (
              gameToken.importMethod === "bin" ||
              gameToken.importMethod === "wxQrcode"
            ) {
              // Binå½¢å¼tokenåˆ·æ–°ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
              const storageKey = gameToken.originalStorageKey || gameToken.name;
              const userToken: ArrayBuffer | null = await getArrayBuffer(
                storageKey,
              );
              console.log("è¯»å–åˆ°çš„ArrayBuffer:", storageKey, userToken);
              if (userToken) {
                const token = await transformToken(userToken);
                updateToken(tokenId, { ...gameToken, token });
                console.log(gameToken);
              }
            }
          }
          // å¿½è§†tokenè¿‡æœŸæç¤ºï¼Œä¸è®°å½•é”™è¯¯æ—¥å¿—
        }
        return;
      }

      const cmd = message.cmd?.toLowerCase();
      const body = message.getData();

      if (cmd === "role_getroleinforesp") {
        syncRandomSeedFromStatistics(tokenId, body, client);
      }

      emitPlus(cmd, {
        tokenId,
        body,
        message,
        client,
        gameData,
      });

      gameLogger.gameMessage(tokenId, cmd, !!body);
    } catch (error) {
      gameLogger.error(`å¤„ç†æ¶ˆæ¯å¤±è´¥ [${tokenId}]:`, error);
    }
  };

  // éªŒè¯tokenæœ‰æ•ˆæ€§
  const validateToken = (token: any) => {
    if (!token) return false;
    if (typeof token !== "string") return false;
    if (token.trim().length === 0) return false;
    // ç®€å•æ£€æŸ¥ï¼štokenåº”è¯¥è‡³å°‘æœ‰ä¸€å®šé•¿åº¦
    if (token.trim().length < 10) return false;
    return true;
  };

  // Base64è§£æåŠŸèƒ½ï¼ˆå¢å¼ºç‰ˆï¼‰
  const parseBase64Token = (base64String: string) => {
    try {
      // è¾“å…¥éªŒè¯
      if (!base64String || typeof base64String !== "string") {
        throw new Error("Tokenå­—ç¬¦ä¸²æ— æ•ˆ");
      }

      // ç§»é™¤å¯èƒ½çš„å‰ç¼€å’Œç©ºæ ¼
      const cleanBase64 = base64String.replace(/^data:.*base64,/, "").trim();

      if (cleanBase64.length === 0) {
        throw new Error("Tokenå­—ç¬¦ä¸²ä¸ºç©º");
      }

      // è§£ç base64
      let decoded;
      try {
        decoded = atob(cleanBase64);
      } catch (decodeError) {
        // å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„Base64ï¼Œä½œä¸ºçº¯æ–‡æœ¬tokenå¤„ç†
        decoded = base64String.trim();
      }

      // å°è¯•è§£æä¸ºJSON
      let tokenData;
      try {
        tokenData = JSON.parse(decoded);
      } catch {
        // ä¸æ˜¯JSONæ ¼å¼ï¼Œä½œä¸ºçº¯tokenå¤„ç†
        tokenData = { token: decoded };
      }

      // æå–å®é™…token
      const actualToken = tokenData.token || tokenData.gameToken || decoded;

      // éªŒè¯tokenæœ‰æ•ˆæ€§
      if (!validateToken(actualToken)) {
        throw new Error(`æå–çš„tokenæ— æ•ˆ: "${actualToken}"`);
      }

      return {
        success: true,
        data: {
          ...tokenData,
          actualToken, // æ·»åŠ æå–å‡ºçš„å®é™…token
        },
      };
    } catch (error) {
      return {
        success: false,
        error: "è§£æå¤±è´¥ï¼š" + error.message,
      };
    }
  };

  const importBase64Token = (
    name: string,
    base64String: string,
    additionalInfo = {},
  ) => {
    const parseResult = parseBase64Token(base64String);

    if (!parseResult.success) {
      return {
        success: false,
        error: parseResult.error,
        message: `Token "${name}" å¯¼å…¥å¤±è´¥: ${parseResult.error}`,
      };
    }

    const tokenData = {
      name,
      token: parseResult.data.actualToken, // ä½¿ç”¨éªŒè¯è¿‡çš„å®é™…token
      base64Token: base64String, // ä¿å­˜åŸå§‹çš„base64å­—ç¬¦ä¸²ç”¨äºé‡è¿
      ...additionalInfo,
      ...parseResult.data, // è§£æå‡ºçš„æ•°æ®è¦†ç›–æ‰‹åŠ¨è¾“å…¥
    };

    try {
      const newToken = addToken(tokenData);

      // æ·»åŠ æ›´å¤šéªŒè¯ä¿¡æ¯åˆ°æˆåŠŸæ¶ˆæ¯
      const tokenInfo = parseResult.data.actualToken;
      const displayToken =
        tokenInfo.length > 20
          ? `${tokenInfo.substring(0, 10)}...${tokenInfo.substring(tokenInfo.length - 6)}`
          : tokenInfo;

      return {
        success: true,
        token: newToken,
        tokenName: name,
        message: `Token "${name}" å¯¼å…¥æˆåŠŸ`,
        details: `å®é™…Token: ${displayToken}`,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        message: `Token "${name}" æ·»åŠ å¤±è´¥: ${error.message}`,
      };
    }
  };

  // è¿æ¥ç®¡ç†è¾…åŠ©å‡½æ•°
  const generateSessionId = () =>
    "session_" + Date.now() + "_" + Math.random().toString(36).substr(2, 9);
  const currentSessionId = generateSessionId();

  // è·å–è¿æ¥é”
  const acquireConnectionLock = async (
    tokenId: string,
    operation = "connect",
  ) => {
    const lockKey = `${tokenId}_${operation}`;
    const connect = connectionLocks.value;
    if (connect[lockKey]) {
      wsLogger.debug(`ç­‰å¾…è¿æ¥é”é‡Šæ”¾: ${tokenId} (${operation})`);
      // ç­‰å¾…ç°æœ‰æ“ä½œå®Œæˆï¼Œæœ€å¤šç­‰å¾…10ç§’
      let attempts = 0;
      while (connect[lockKey] && attempts < 100) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        attempts++;
      }
      if (connect[lockKey]) {
        wsLogger.warn(`è¿æ¥é”ç­‰å¾…è¶…æ—¶: ${tokenId} (${operation})`);
        return false;
      }
    }
    connect[lockKey] = {
      tokenId,
      operation,
      timestamp: Date.now(),
      sessionId: currentSessionId,
    };
    wsLogger.connectionLock(tokenId, operation, true);
    return true;
  };

  // é‡Šæ”¾è¿æ¥é”
  const releaseConnectionLock = (tokenId: string, operation = "connect") => {
    const lockKey = `${tokenId}_${operation}`;
    if (connectionLocks.value[lockKey]) {
      delete connectionLocks.value[lockKey];
      wsLogger.connectionLock(tokenId, operation, false);
    }
  };

  // æ›´æ–°è·¨æ ‡ç­¾é¡µè¿æ¥çŠ¶æ€
  const updateCrossTabConnectionState = (
    tokenId: string,
    action: string,
    sessionId: string = currentSessionId,
  ) => {
    let state = useLocalStorage(`ws_connection_${tokenId}`, {
      action, // 'connecting', 'connected', 'disconnecting', 'disconnected'
      sessionId,
      timestamp: Date.now(),
      url: window.location.href,
    });

    if (activeConnections.value) {
      activeConnections.value[tokenId] = state.value;
    }
  };

  // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–æ ‡ç­¾é¡µçš„æ´»è·ƒè¿æ¥
  const checkCrossTabConnection = (tokenId: string) => {
    const storageKey = `ws_connection_${tokenId}`;
    try {
      const stored = localStorage.getItem(storageKey);
      if (stored) {
        const state = JSON.parse(stored);
        const isRecent = Date.now() - state.timestamp < 30000; // 30ç§’å†…çš„çŠ¶æ€è®¤ä¸ºæ˜¯æ´»è·ƒçš„
        const isDifferentSession = state.sessionId !== currentSessionId;

        if (
          isRecent &&
          isDifferentSession &&
          (state.action === "connecting" || state.action === "connected")
        ) {
          wsLogger.debug(`æ£€æµ‹åˆ°å…¶ä»–æ ‡ç­¾é¡µçš„æ´»è·ƒè¿æ¥: ${tokenId}`);
          return state;
        }
      }
    } catch (error) {
      wsLogger.warn("æ£€æŸ¥è·¨æ ‡ç­¾é¡µè¿æ¥çŠ¶æ€å¤±è´¥:", error);
    }
    return null;
  };

  // WebSocketè¿æ¥ç®¡ç†ï¼ˆå†…éƒ¨å®ç° - å®é™…åˆ›å»ºè¿æ¥ï¼‰
  const createWebSocketConnectionInternal = async (
    tokenId: string,
    base64Token: string,
    customWsUrl = null,
  ) => {
    wsLogger.info(`å¼€å§‹åˆ›å»ºè¿æ¥: ${tokenId}`);

    // 1. è·å–è¿æ¥é”ï¼Œé˜²æ­¢ç«æ€æ¡ä»¶
    const lockAcquired = await acquireConnectionLock(tokenId, "connect");
    if (!lockAcquired) {
      wsLogger.error(`æ— æ³•è·å–è¿æ¥é”: ${tokenId}`);
      return null;
    }

    try {
      // 2. æ£€æŸ¥è·¨æ ‡ç­¾é¡µè¿æ¥çŠ¶æ€
      const crossTabState = checkCrossTabConnection(tokenId);
      if (crossTabState) {
        wsLogger.debug(`è·³è¿‡åˆ›å»ºï¼Œå…¶ä»–æ ‡ç­¾é¡µå·²æœ‰è¿æ¥: ${tokenId}`);
        releaseConnectionLock(tokenId, "connect");
        return null;
      }

      // 3. æ›´æ–°è·¨æ ‡ç­¾é¡µçŠ¶æ€ä¸ºè¿æ¥ä¸­
      updateCrossTabConnectionState(tokenId, "connecting");

      // 4. å¦‚æœå­˜åœ¨ç°æœ‰è¿æ¥ï¼Œå…ˆä¼˜é›…å…³é—­
      if (wsConnections.value[tokenId]) {
        wsLogger.debug(`ä¼˜é›…å…³é—­ç°æœ‰è¿æ¥: ${tokenId}`);
        await closeWebSocketConnectionAsync(tokenId);
      }

      // 5. è§£ætoken
      const parseResult = parseBase64Token(base64Token);
      let actualToken;
      if (parseResult.success) {
        actualToken = parseResult.data.actualToken;
      } else {
        if (validateToken(base64Token)) {
          actualToken = base64Token;
        } else {
          throw new Error(`Tokenæ— æ•ˆ: ${parseResult.error}`);
        }
      }

      // 6. æ„å»ºWebSocket URL
      const baseWsUrl = `wss://xxz-xyzw.hortorgames.com/agent?p=${encodeURIComponent(actualToken)}&e=x&lang=chinese`;

      const wsUrl = customWsUrl || baseWsUrl;

      wsLogger.debug(
        `Token: ${actualToken.substring(0, 10)}...${actualToken.slice(-4)}`,
      );

      // 7. åˆ›å»ºæ–°çš„WebSocketå®¢æˆ·ç«¯ï¼ˆå¢å¼ºç‰ˆï¼‰
      const wsClient = new XyzwWebSocketClient({
        url: wsUrl,
        utils: g_utils,
        heartbeatMs: 5000,
      });

      // 8. è®¾ç½®è¿æ¥çŠ¶æ€ï¼ˆå¸¦ä¼šè¯IDï¼‰
      wsConnections.value[tokenId] = {
        client: wsClient,
        status: "connecting",
        tokenId,
        wsUrl,
        actualToken,
        sessionId: currentSessionId,
        connectedAt: null,
        lastMessage: null,
        lastError: null,
        reconnectAttempts: 0,
        randomSeedSynced: false,
        lastRandomSeedSource: null,
        lastRandomSeed: null,
      };

      // 9. è®¾ç½®äº‹ä»¶ç›‘å¬ï¼ˆå¢å¼ºç‰ˆï¼‰
      wsClient.onConnect = () => {
        wsLogger.wsConnect(tokenId);
        if (wsConnections.value[tokenId]) {
          wsConnections.value[tokenId].status = "connected";
          wsConnections.value[tokenId].connectedAt = new Date().toISOString();
        // åªæœ‰åœ¨æˆåŠŸç»´æŒè¿æ¥ä¸€æ®µæ—¶é—´åæ‰é‡ç½®é‡è¿è®¡æ•°å™¨
        // åœ¨tokenè¿‡æœŸå¯¼è‡´çš„å¿«é€Ÿæ–­å¼€é‡è¿åœºæ™¯ä¸­ï¼Œä¸é‡ç½®é‡è¿è®¡æ•°å™¨
        // wsConnections.value[tokenId].reconnectAttempts = 0;
        wsConnections.value[tokenId].randomSeedSynced = false;
        wsConnections.value[tokenId].lastRandomSeedSource = null;
        wsConnections.value[tokenId].lastRandomSeed = null;
        }
        updateCrossTabConnectionState(tokenId, "connected");
        releaseConnectionLock(tokenId, "connect");
        localStorage.removeItem("xyzw_chat_msg_list");
        try {
          wsClient.send("role_getroleinfo");
        } catch (error) {
          wsLogger.warn(`åˆå§‹åŒ–è§’è‰²ä¿¡æ¯è¯·æ±‚å¤±è´¥ [${tokenId}]`, error);
        }
      };

      wsClient.onDisconnect = (event) => {
        const reason = event.code === 1006 ? "å¼‚å¸¸æ–­å¼€" : event.reason || "";
        wsLogger.wsDisconnect(tokenId, reason);
        if (wsConnections.value[tokenId]) {
          wsConnections.value[tokenId].status = "disconnected";
          wsConnections.value[tokenId].randomSeedSynced = false;
          
          // è®°å½•æ–­å¼€æ¬¡æ•°
          if (!wsConnections.value[tokenId].disconnectCount) {
            wsConnections.value[tokenId].disconnectCount = 0;
          }
          wsConnections.value[tokenId].disconnectCount++;
          wsConnections.value[tokenId].lastDisconnectTime = new Date().toISOString();
        }
        updateCrossTabConnectionState(tokenId, "disconnected");
        
        // è‡ªåŠ¨é‡è¿é€»è¾‘ï¼ˆä»…å¯¹å¼‚å¸¸æ–­å¼€1006ï¼‰
        if (event.code === 1006) {
          const connection = wsConnections.value[tokenId];
          const maxReconnectAttempts = 3; // æœ€å¤§é‡è¿æ¬¡æ•°
          const reconnectDelay = 3000; // é‡è¿å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
          
          // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡è¿ï¼ˆè¿ç»­å¤±è´¥æ¬¡æ•°æœªè¶…è¿‡é™åˆ¶ï¼‰
          if (connection && 
              (!connection.reconnectAttempts || connection.reconnectAttempts < maxReconnectAttempts)) {
            
            // å¢åŠ é‡è¿å°è¯•è®¡æ•°
            if (!connection.reconnectAttempts) {
              connection.reconnectAttempts = 0;
            }
            connection.reconnectAttempts++;
            
            wsLogger.info(
              `è®¡åˆ’è‡ªåŠ¨é‡è¿ [${tokenId}] (${connection.reconnectAttempts}/${maxReconnectAttempts})ï¼Œå»¶è¿Ÿ ${reconnectDelay}ms`
            );
            
            setTimeout(() => {
              // æ£€æŸ¥æ˜¯å¦ä»ç„¶éœ€è¦é‡è¿ï¼ˆå¯èƒ½ç”¨æˆ·å·²æ‰‹åŠ¨é‡è¿ï¼‰
              if (
                wsConnections.value[tokenId] &&
                wsConnections.value[tokenId].status === "disconnected"
              ) {
                wsLogger.info(`å¼€å§‹è‡ªåŠ¨é‡è¿ [${tokenId}]`);
                
                // é‡æ–°åˆ›å»ºè¿æ¥
                const token = gameTokens.value.find((t) => t.id === tokenId);
                if (token && token.base64Token) {
                  // ä½¿ç”¨ç°æœ‰çš„è¿æ¥æ–¹æ³•é‡æ–°è¿æ¥
                  createWebSocketConnectionInternal(
                    tokenId,
                    token.base64Token,
                    null,
                  ).catch((error) => {
                    wsLogger.error(`è‡ªåŠ¨é‡è¿å¤±è´¥ [${tokenId}]:`, error);
                  });
                } else {
                  wsLogger.warn(`æ— æ³•è‡ªåŠ¨é‡è¿ [${tokenId}]: Tokenä¸å­˜åœ¨æˆ–æ— æ•ˆ`);
                }
              } else {
                wsLogger.debug(`è·³è¿‡è‡ªåŠ¨é‡è¿ [${tokenId}]: è¿æ¥çŠ¶æ€å·²æ”¹å˜`);
              }
            }, reconnectDelay);
          } else if (connection && connection.reconnectAttempts >= maxReconnectAttempts) {
            wsLogger.warn(
              `è¾¾åˆ°æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œåœæ­¢è‡ªåŠ¨é‡è¿ [${tokenId}] (${connection.reconnectAttempts}/${maxReconnectAttempts})`
            );
          }
        }
      };

      wsClient.onError = (error) => {
        wsLogger.wsError(tokenId, error);
        if (wsConnections.value[tokenId]) {
          wsConnections.value[tokenId].status = "error";
          wsConnections.value[tokenId].lastError = {
            timestamp: new Date().toISOString(),
            error: error.toString(),
            url: wsUrl,
          };
        }
        releaseConnectionLock(tokenId, "connect");
      };

      // 10. è®¾ç½®æ¶ˆæ¯ç›‘å¬
      wsClient.setMessageListener((message: ProtoMsg) => {
        const cmd = message?.cmd || "unknown";
        wsLogger.wsMessage(tokenId, cmd, true);

        if (wsConnections.value[tokenId]) {
          wsConnections.value[tokenId].lastMessage = {
            timestamp: new Date().toISOString(),
            data: message,
            cmd: message?.cmd,
          };
          handleGameMessage(tokenId, message, wsClient);
        }
      });

      // 11. åˆå§‹åŒ–è¿æ¥
      wsClient.init();

      wsLogger.verbose(`WebSocketå®¢æˆ·ç«¯åˆ›å»ºæˆåŠŸ: ${tokenId}`);
      return wsClient;
    } catch (error) {
      wsLogger.error(`åˆ›å»ºè¿æ¥å¤±è´¥ [${tokenId}]:`, error);
      updateCrossTabConnectionState(tokenId, "disconnected");
      releaseConnectionLock(tokenId, "connect");
      return null;
    }
  };

  // å¼‚æ­¥ç‰ˆæœ¬çš„å…³é—­è¿æ¥ï¼ˆä¼˜é›…å…³é—­ï¼‰
  const closeWebSocketConnectionAsync = async (tokenId: string) => {
    const lockAcquired = await acquireConnectionLock(tokenId, "disconnect");
    if (!lockAcquired) {
      wsLogger.warn(`æ— æ³•è·å–æ–­å¼€è¿æ¥é”: ${tokenId}`);
      return;
    }

    try {
      const connection = wsConnections.value[tokenId];
      if (connection && connection.client) {
        wsLogger.debug(`å¼€å§‹ä¼˜é›…å…³é—­è¿æ¥: ${tokenId}`);

        connection.status = "disconnecting";
        updateCrossTabConnectionState(tokenId, "disconnecting");

        connection.client.disconnect();

        // ç­‰å¾…è¿æ¥å®Œå…¨å…³é—­
        await new Promise((resolve) => {
          const checkDisconnected = () => {
            if (!connection.client.connected) {
              resolve();
            } else {
              setTimeout(checkDisconnected, 100);
            }
          };
          setTimeout(resolve, 5000); // æœ€å¤šç­‰å¾…5ç§’
          checkDisconnected();
        });

        delete wsConnections.value[tokenId];
        updateCrossTabConnectionState(tokenId, "disconnected");
        wsLogger.info(`è¿æ¥å·²ä¼˜é›…å…³é—­: ${tokenId}`);
      }
    } catch (error) {
      wsLogger.error(`å…³é—­è¿æ¥å¤±è´¥ [${tokenId}]:`, error);
    } finally {
      releaseConnectionLock(tokenId, "disconnect");
    }
  };

  // è·å–å½“å‰å·²è¿æ¥çš„è¿æ¥æ•°ï¼ˆåªç»Ÿè®¡ connected çŠ¶æ€çš„è¿æ¥ï¼‰
  const getConnectedCount = () => {
    return Object.values(wsConnections.value).filter(
      (conn) => conn.status === "connected"
    ).length;
  };

  // æ–­å¼€æœ€æ—§çš„è¿æ¥ï¼ˆæŒ‰è¿æ¥æ—¶é—´æ’åºï¼Œä¼˜å…ˆæ–­å¼€éå½“å‰é€‰ä¸­çš„Tokenï¼‰
  const disconnectOldestConnection = async () => {
    const connectedConnections = Object.entries(wsConnections.value)
      .filter(([_, conn]) => conn.status === "connected")
      .map(([tokenId, conn]) => ({
        tokenId,
        connectedAt: conn.connectedAt || "0",
        connection: conn,
        isSelected: tokenId === selectedTokenId.value, // æ ‡è®°æ˜¯å¦ä¸ºå½“å‰é€‰ä¸­çš„Token
      }))
      .sort((a, b) => {
        // ä¼˜å…ˆæ–­å¼€éå½“å‰é€‰ä¸­çš„Token
        if (a.isSelected !== b.isSelected) {
          return a.isSelected ? 1 : -1; // é€‰ä¸­çš„æ’åœ¨åé¢
        }
        // å¦‚æœéƒ½æ˜¯é€‰ä¸­æˆ–éƒ½ä¸æ˜¯é€‰ä¸­ï¼ŒæŒ‰è¿æ¥æ—¶é—´æ’åºï¼Œæœ€æ—©çš„åœ¨å‰
        return new Date(a.connectedAt).getTime() - new Date(b.connectedAt).getTime();
      });

    if (connectedConnections.length > 0) {
      const oldestConnection = connectedConnections[0];
      wsLogger.info(
        `è¿æ¥æ•°å·²è¾¾ä¸Šé™(${maxConcurrentConnections.value})ï¼Œæ–­å¼€æœ€æ—§è¿æ¥: ${oldestConnection.tokenId} (è¿æ¥æ—¶é—´: ${oldestConnection.connectedAt}, æ˜¯å¦é€‰ä¸­: ${oldestConnection.isSelected})`
      );
      await closeWebSocketConnectionAsync(oldestConnection.tokenId);
      return true;
    }
    return false;
  };

  // WebSocketè¿æ¥ç®¡ç†ï¼ˆå¤–éƒ¨è°ƒç”¨ - å¸¦è¿æ¥æ•°é™åˆ¶å’Œè‡ªåŠ¨æ–­å¼€æœ€æ—§è¿æ¥ï¼‰
  const createWebSocketConnection = async (
    tokenId: string,
    base64Token: string,
    customWsUrl = null,
  ) => {
    // æ£€æŸ¥å½“å‰å·²è¿æ¥çš„è¿æ¥æ•°
    const currentConnectedCount = getConnectedCount();
    
    // å¦‚æœå½“å‰è¦è¿æ¥çš„tokenå·²ç»è¿æ¥ï¼Œç›´æ¥è¿”å›
    if (wsConnections.value[tokenId]?.status === "connected") {
      wsLogger.debug(`Tokenå·²è¿æ¥ï¼Œè·³è¿‡: ${tokenId}`);
      return wsConnections.value[tokenId]?.client || null;
    }

    // å¦‚æœè¿æ¥æ•°å·²è¾¾ä¸Šé™ï¼Œæ–­å¼€æœ€æ—§çš„è¿æ¥
    if (currentConnectedCount >= maxConcurrentConnections.value) {
      wsLogger.info(
        `å½“å‰è¿æ¥æ•°: ${currentConnectedCount}/${maxConcurrentConnections.value}ï¼Œéœ€è¦æ–­å¼€æœ€æ—§è¿æ¥ä»¥åˆ›å»ºæ–°è¿æ¥: ${tokenId}`
      );
      const disconnected = await disconnectOldestConnection();
      if (!disconnected) {
        wsLogger.warn(`æ— æ³•æ–­å¼€æ—§è¿æ¥ï¼Œæ–°è¿æ¥å¯èƒ½å¤±è´¥: ${tokenId}`);
      }
      // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ—§è¿æ¥å·²å…³é—­
      await new Promise((resolve) => setTimeout(resolve, 300));
    }

    // æ£€æŸ¥å½“å‰æ´»è·ƒè¿æ¥æ•°ï¼ˆåŒ…æ‹¬æ­£åœ¨è¿æ¥çš„ï¼‰
    if (activeConnectionCount.value < maxConcurrentConnections.value) {
      // ç›´æ¥åˆ›å»ºè¿æ¥
      activeConnectionCount.value++;
      try {
        const client = await createWebSocketConnectionInternal(tokenId, base64Token, customWsUrl);
        return client;
      } catch (error) {
        wsLogger.error(`åˆ›å»ºè¿æ¥å¤±è´¥ [${tokenId}]:`, error);
        return null;
      } finally {
        activeConnectionCount.value--;
        // è¿æ¥å®Œæˆåï¼Œæ£€æŸ¥é˜Ÿåˆ—ä¸­æ˜¯å¦è¿˜æœ‰ç­‰å¾…çš„è¿æ¥è¯·æ±‚
        setTimeout(processConnectionQueue, connectionDelay.value);
      }
    } else {
      // åŠ å…¥è¿æ¥é˜Ÿåˆ—
      enqueueConnection(tokenId);
      return null;
    }
  };

  /**
   * å»ºç«‹WebSocketè¿æ¥ (ä¾›å¤–éƒ¨ç®¡ç†å™¨è°ƒç”¨)
   * @param tokenId Token ID
   */
  const connectWebSocket = async (tokenId: string) => {
    const token = gameTokens.value.find((t) => t.id === tokenId);
    if (!token) {
      wsLogger.error(`connectWebSocket: Token not found [${tokenId}]`);
      return null;
    }
    return createWebSocketConnection(tokenId, token.token, token.wsUrl);
  };

  /**
   * æ–­å¼€WebSocketè¿æ¥ (ä¾›å¤–éƒ¨ç®¡ç†å™¨è°ƒç”¨)
   * @param tokenId Token ID
   */
  const disconnectWebSocket = async (tokenId: string) => {
    return closeWebSocketConnectionAsync(tokenId);
  };

  // åŒæ­¥ç‰ˆæœ¬çš„å…³é—­è¿æ¥ï¼ˆä¿æŒå‘åå…¼å®¹ï¼‰
  const closeWebSocketConnection = (tokenId: string) => {
    closeWebSocketConnectionAsync(tokenId).catch((error) => {
      wsLogger.error(`å…³é—­è¿æ¥å¼‚æ­¥æ“ä½œå¤±è´¥ [${tokenId}]:`, error);
    });
  };

  const getWebSocketStatus = (tokenId: string) => {
    return wsConnections.value[tokenId]?.status || "disconnected";
  };

  // è·å–WebSocketå®¢æˆ·ç«¯
  const getWebSocketClient = (tokenId: string) => {
    return wsConnections.value[tokenId]?.client || null;
  };

  // è®¾ç½®æ¶ˆæ¯ç›‘å¬å™¨
  const setMessageListener = (listener: any) => {
    if (selectedToken.value) {
      const connection = wsConnections.value[selectedToken.value.id];
      if (connection && connection.client) {
        connection.client.setMessageListener(listener);
      }
    }
  };

  // è®¾ç½®æ˜¯å¦æ˜¾ç¤ºæ¶ˆæ¯
  const setShowMsg = (show: any) => {
    if (selectedToken.value) {
      const connection = wsConnections.value[selectedToken.value.id];
      if (connection && connection.client) {
        connection.client.setShowMsg(show);
      }
    }
  };

  // å‘é€æ¶ˆæ¯åˆ°WebSocket
  const sendMessage = (
    tokenId: string,
    cmd: string,
    params = {},
    options = {},
  ) => {
    const connection = wsConnections.value[tokenId];
    if (!connection || connection.status !== "connected") {
      wsLogger.error(`WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ [${tokenId}]`);
      return false;
    }

    try {
      const client = connection.client;
      if (!client) {
        wsLogger.error(`WebSocketå®¢æˆ·ç«¯ä¸å­˜åœ¨ [${tokenId}]`);
        return false;
      }

      client.send(cmd, params, options);
      wsLogger.wsMessage(tokenId, cmd, false);

      return true;
    } catch (error) {
      wsLogger.error(`å‘é€å¤±è´¥ [${tokenId}] ${cmd}:`, error.message);
      return false;
    }
  };

  // Promiseç‰ˆå‘é€æ¶ˆæ¯
  const sendMessageWithPromise = async (
    tokenId: string,
    cmd: string,
    params = {},
    timeout = 5000,
  ) => {
    const connection = wsConnections.value[tokenId];
    
    // å¦‚æœè¿æ¥ä¸å­˜åœ¨æˆ–å·²æ–­å¼€ï¼Œå°è¯•è‡ªåŠ¨è¿æ¥
    if (!connection || connection.status === "disconnected" || connection.status === "error") {
      const token = gameTokens.value.find((t) => t.id === tokenId);
      if (token) {
        wsLogger.info(`è¿æ¥æœªå»ºç«‹ï¼Œè‡ªåŠ¨è¿æ¥Token: ${tokenId}`);
        selectToken(tokenId, false);
        // ç­‰å¾…è¿æ¥å»ºç«‹ï¼ˆæœ€å¤šç­‰å¾…5ç§’ï¼‰
        let waitCount = 0;
        const maxWait = 50; // 50æ¬¡ * 100ms = 5ç§’
        while (waitCount < maxWait) {
          await new Promise((resolve) => setTimeout(resolve, 100));
          const newConnection = wsConnections.value[tokenId];
          if (newConnection && newConnection.status === "connected") {
            break;
          }
          if (newConnection && newConnection.status === "error") {
            return Promise.reject(new Error(`WebSocketè¿æ¥å¤±è´¥ [${tokenId}]`));
          }
          waitCount++;
        }
        // æ£€æŸ¥æœ€ç»ˆè¿æ¥çŠ¶æ€
        const finalConnection = wsConnections.value[tokenId];
        if (!finalConnection || finalConnection.status !== "connected") {
          return Promise.reject(new Error(`WebSocketè¿æ¥è¶…æ—¶ [${tokenId}]`));
        }
      } else {
        return Promise.reject(new Error(`WebSocketæœªè¿æ¥ï¼Œä¸”Tokenä¸å­˜åœ¨ [${tokenId}]`));
      }
    }
    
    // å¦‚æœæ­£åœ¨è¿æ¥ä¸­ï¼Œç­‰å¾…è¿æ¥å®Œæˆ
    if (connection.status === "connecting") {
      wsLogger.info(`WebSocketè¿æ¥ä¸­ï¼Œç­‰å¾…è¿æ¥å®Œæˆ [${tokenId}]`);
      let waitCount = 0;
      const maxWait = 50; // 50æ¬¡ * 100ms = 5ç§’
      while (waitCount < maxWait) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        const currentConnection = wsConnections.value[tokenId];
        if (currentConnection && currentConnection.status === "connected") {
          break;
        }
        if (currentConnection && currentConnection.status === "error") {
          return Promise.reject(new Error(`WebSocketè¿æ¥å¤±è´¥ [${tokenId}]`));
        }
        waitCount++;
      }
      // æ£€æŸ¥æœ€ç»ˆè¿æ¥çŠ¶æ€
      const finalConnection = wsConnections.value[tokenId];
      if (!finalConnection || finalConnection.status !== "connected") {
        return Promise.reject(new Error(`WebSocketè¿æ¥è¶…æ—¶ [${tokenId}]`));
      }
    }
    
    // åªæœ‰è¿æ¥æˆåŠŸæ‰èƒ½å‘é€
    const finalConnection = wsConnections.value[tokenId];
    if (!finalConnection || finalConnection.status !== "connected") {
      return Promise.reject(new Error(`WebSocketæœªè¿æ¥ [${tokenId}]ï¼ŒçŠ¶æ€: ${finalConnection?.status || "unknown"}`));
    }

    const client = finalConnection.client;
    if (!client) {
      return Promise.reject(new Error(`WebSocketå®¢æˆ·ç«¯ä¸å­˜åœ¨ [${tokenId}]`));
    }

    // ä¸ºæˆ˜æ–—ç›¸å…³å‘½ä»¤è‡ªåŠ¨æ³¨å…¥ battleVersion
    const battleCommands = [
      "fight_startareaarena",
      "fight_startpvp",
      "fight_starttower",
      "fight_startboss",
      "fight_startlegionboss",
      "fight_startdungeon",
    ];
    if (battleCommands.includes(cmd)) {
      const battleVersion = gameData.value.battleVersion;
      params = { battleVersion, ...params };
      wsLogger.info(
        `âš”ï¸ [æˆ˜æ–—å‘½ä»¤] æ³¨å…¥ battleVersion: ${battleVersion} [${cmd}]`,
      );
    }

    try {
      const result = await client.sendWithPromise(cmd, params, timeout);

      // ç‰¹æ®Šæ—¥å¿—ï¼šfight_starttower å“åº”
      if (cmd === "fight_starttower") {
        wsLogger.info(`ğŸ—¼ [å’¸å°†å¡”] æ”¶åˆ°çˆ¬å¡”å“åº” [${tokenId}]:`, result);
      }

      return result;
    } catch (error) {
      // ç‰¹æ®Šæ—¥å¿—ï¼šfight_starttower é”™è¯¯
      if (cmd === "fight_starttower") {
        wsLogger.error(`ğŸ—¼ [å’¸å°†å¡”] çˆ¬å¡”è¯·æ±‚å¤±è´¥ [${tokenId}]:`, error.message);
      }
      return Promise.reject(error);
    }
  };

  // å‘é€å¿ƒè·³æ¶ˆæ¯
  const sendHeartbeat = (tokenId: string) => {
    return sendMessage(tokenId, "heart_beat");
  };

  // å‘é€è·å–è§’è‰²ä¿¡æ¯è¯·æ±‚ï¼ˆå¼‚æ­¥å¤„ç†ï¼‰
  const sendGetRoleInfo = async (tokenId: string, params = {}, retryCount = 0) => {
    try {
      // å¢åŠ è¶…æ—¶æ—¶é—´åˆ°15ç§’ï¼Œå¹¶æ·»åŠ é‡è¯•æœºåˆ¶
      const timeout = 15000;
      const roleInfo = await sendMessageWithPromise(
        tokenId,
        "role_getroleinfo",
        params,
        timeout,
      );

      // æ‰‹åŠ¨æ›´æ–°æ¸¸æˆæ•°æ®ï¼ˆå› ä¸ºå“åº”å¯èƒ½ä¸ä¼šè‡ªåŠ¨è§¦å‘æ¶ˆæ¯å¤„ç†ï¼‰
      if (roleInfo) {
        gameData.value.roleInfo = roleInfo;
        gameData.value.lastUpdated = new Date().toISOString();
        gameLogger.verbose("è§’è‰²ä¿¡æ¯å·²é€šè¿‡ Promise æ›´æ–°");
      }

      return roleInfo;
    } catch (error) {
      gameLogger.error(`è·å–è§’è‰²ä¿¡æ¯å¤±è´¥ [${tokenId}]:`, error.message);

      // é‡è¯•æœºåˆ¶ï¼šæœ€å¤šé‡è¯•2æ¬¡ï¼Œæ¯æ¬¡é—´éš”1ç§’
      if (retryCount < 2) {
        gameLogger.info(`æ­£åœ¨é‡è¯•è·å–è§’è‰²ä¿¡æ¯ [${tokenId}]ï¼Œé‡è¯•æ¬¡æ•°: ${retryCount + 1}`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        return sendGetRoleInfo(tokenId, params, retryCount + 1);
      }

      throw error;
    }
  };

  // å‘é€è·å–æ•°æ®ç‰ˆæœ¬è¯·æ±‚
  const sendGetDataBundleVersion = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "system_getdatabundlever", params);
  };

  // å‘é€ç­¾åˆ°è¯·æ±‚
  const sendSignIn = (tokenId: string) => {
    return sendMessageWithPromise(tokenId, "system_signinreward");
  };

  // å‘é€é¢†å–æ—¥å¸¸ä»»åŠ¡å¥–åŠ±
  const sendClaimDailyReward = (tokenId: string, rewardId = 0) => {
    return sendMessageWithPromise(tokenId, "task_claimdailyreward", {
      rewardId,
    });
  };

  // å‘é€è·å–é˜Ÿä¼ä¿¡æ¯
  const sendGetTeamInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "presetteam_getinfo", params);
  };

  // å‘é€å†›å›¢å•†åº—è´­ä¹°å•†å“
  const sendLegionStoreBuyGoods = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legion_storebuygoods", params);
  };

  // å‘é€é¢†å–çå®é˜æ¯æ—¥å…è´¹å¥–åŠ±
  const sendCollectionClaimFreeReward = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "collection_claimfreereward", params);
  };

  // å‘é€é¢†å–åŠŸæ³•æŒ‚æœºå¥–åŠ±
  const sendLegacyClaimHangup = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_claimhangup", params);
  };

  // å‘é€é¢†å–åŠŸæ³•ç¤¼ç‰©
  const sendLegacyClaimGift = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_claimgift", params);
  };

  // å‘é€æäº¤å¯†ç 
  const sendRoleCommitPassword = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "role_commitpassword", params);
  };

  // å‘é€èµ é€åŠŸæ³•
  const sendLegacySendGift = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_sendgift", params);
  };

  // å‘é€è·å–åŠŸæ³•èµ é€è¯¦æƒ…
  const sendLegacyGetGifts = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_getgifts", params);
  };

  // å‘é€è·å–åŠŸæ³•è¯¦æƒ…
  const sendLegacyGetInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_getinfo", params);
  };

  // å‘é€æ¿€æ´»åŠŸæ³•å›¾é‰´
  const sendLegacyActivate = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legacy_activatebook", params);
  };

  // å‘é€è·å–å†›å›¢ä¿¡æ¯
  const sendLegionGetInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legion_getinfo", params);
  };

  // å‘é€è·å–å™©æ¢¦ä¿¡æ¯
  const sendNightmareGetRoleInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_getroleinfo", params);
  };

  // å‘é€åæ®¿è½¬ç›˜
  const sendNightmareClickTurntable = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_clickturntable", params);
  };

  // å‘é€åæ®¿è½¬ç›˜å¥–åŠ±æ¬¡æ•°
  const sendNightmareClaimTurnRewardTimes = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_claimturnrewardtimes", params);
  };

  // å‘é€åæ®¿æˆ˜æ–—
  const sendNightmareFight = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_fight", params);
  };

  // å‘é€è®¾ç½®åæ®¿å‡ºæˆ˜äººå‘˜
  const sendNightmareSetFighter = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_setfighter", params);
  };

  // å‘é€åæ®¿æ¢å¤
  const sendNightmareRestore = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_restore", params);
  };

  // å‘é€åæ®¿å›¾é‰´å¥–åŠ±é¢†å–
  const sendNightmareClaimBook = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_claimbook", params);
  };

  // å‘é€åæ®¿å‘¨å¥–åŠ±é¢†å–
  const sendNightmareClaimWeekReward = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "nightmare_claimweekreward", params);
  };

  // å‘é€è·å–è§’è‰²é˜Ÿä¼ä¿¡æ¯
  const sendMatchteamGetRoleTeamInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "matchteam_getroleteaminfo", params);
  };

  // å‘é€è¸¢å‡ºé˜Ÿä¼æˆå‘˜
  const sendMatchteamKick = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "matchteam_kick", params);
  };

  // å‘é€æ‰“å¼€é˜Ÿä¼
  const sendMatchteamOpenTeam = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "matchteam_openteam", params);
  };

  // å‘é€ç¦»å¼€é˜Ÿä¼
  const sendMatchteamLeave = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "matchteam_leave", params);
  };

  // å‘é€ä¿å­˜é¢„è®¾é˜Ÿä¼ï¼ˆåˆ‡æ¢é˜µå®¹ï¼‰
  const sendPresetteamSaveTeam = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "presetteam_saveteam", params);
  };

  // å‘é€å¼€å§‹ç¯ç¥æˆ˜æ–—
  const sendFightStartGenie = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "fight_startgenie", params);
  };

  // å‘é€å¼€å§‹å…³å¡æˆ˜æ–—ï¼ˆç”¨äºè·å–å½“å‰é˜µå®¹ä¿¡æ¯ï¼‰
  const sendFightStartLevel = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "fight_startlevel", params);
  };

  // å‘é€è‹±é›„äº¤æ¢
  const sendHeroExchange = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "hero_exchange", params);
  };

  // å‘é€è®¡ç®—è‹±é›„æˆ˜åŠ›
  const sendHeroCalcpowerbyteam = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "hero_calcpowerbyteam", params);
  };

  // å‘é€ç¯ç¥æ‰«è¡
  const sendGenieSweep = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "genie_sweep", params);
  };

  // å‘é€ç§‘æŠ€äº¤æ¢
  const sendLegionExchangeResearch = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legion_exchangeresearch", params);
  };

  // å‘é€å†›å›¢ç ”ç©¶
  const sendLegionResearch = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legion_research", params);
  };

  // å‘é€é‡ç½®å†›å›¢ç ”ç©¶
  const sendLegionResetResearch = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "legion_resetresearch", params);
  };

  // å‘é€è·å–é¢„è®¾é˜Ÿä¼ä¿¡æ¯
  const sendPresetteamGetInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "presetteam_getinfo", params);
  };

  // å‘é€è·å–é»‘å¸‚è´­ä¹°è®¾ç½®
  const sendStoreGetPurchase = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "store_getpurchase", params);
  };

  // å‘é€é¢†å–å®ç®±å¥–åŠ±
  const sendItemClaimBoxPointReward = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "item_claimboxpointreward", params);
  };

  // å‘é€é¢†å–ä»»åŠ¡å¥–åŠ±
  const sendActivityClaimTaskReward = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_claimtaskreward", params);
  };

  // å‘é€è·å–æ´»åŠ¨æ¸¸æˆä¿¡æ¯
  const sendActivityGetActeGameInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_getactegameinfo", params);
  };

  // å‘é€é¢†å–æ´»åŠ¨æ¸¸æˆé˜¶æ®µå¥–åŠ±
  const sendActivityActeGameStageClaim = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_actegamestageclaim", params);
  };

  // å‘é€å¼€å§‹æ´»åŠ¨æ¸¸æˆ
  const sendActivityStarteGame = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_startegame", params);
  };

  // å‘é€æ´»åŠ¨é€šç”¨è´­ä¹°å•†å“
  const sendActivityCommonBuyGoods = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_commonbuygoods", params);
  };

  // å‘é€äº”ä¸€æŠ½å¥–æ´»åŠ¨
  const sendActivityMaydaylottery = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "activity_maydaylottery", params);
  };

  // å‘é€èåˆç›’é¢†å–èåˆè¿›åº¦
  const sendMergeboxClaimMergeProgress = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "mergebox_claimmergeprogress", params);
  };

  // å‘é€èåˆç›’é¢†å–æ¶ˆè€—è¿›åº¦
  const sendMergeboxClaimCostProgress = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "mergebox_claimcostprogress", params);
  };

  // å‘é€è¿›åŒ–å¡”é¢†å–ä»»åŠ¡
  const sendEvotowerClaimTask = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "evotower_claimtask", params);
  };

  // å‘é€è¿›åŒ–å¡”é¢†å–å†›å›¢ç‰¹æƒ
  const sendEvotowerClaimLegionPrivilege = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "evotower_claimlegionprivilege", params);
  };

  // å‘é€èåˆç›’åˆå¹¶ç‰©å“
  const sendMergeboxMergeItem = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "mergebox_mergeitem", params);
  };

  // å‘é€èåˆç›’å¼€ç›’
  const sendMergeboxOpenBox = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "mergebox_openbox", params);
  };

  // å‘é€å¡”å¼€å§‹
  const sendTowersStart = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "towers_start", params);
  };

  // å‘é€å¡”æˆ˜æ–—
  const sendTowersFight = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "towers_fight", params);
  }

  // å‘é€å¡”ä¿¡æ¯è·å–
  const sendTowersGetInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "towers_getinfo", params);
  };

  // å‘é€é¢†å–æ‰€æœ‰é‚®ä»¶é™„ä»¶
  const sendMailClaimAllAttachment = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "mail_claimallattachment", params);
  };

  // å‘é€æ‰“å¼€é“å…·åŒ…
  const sendItemOpenPack = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "item_openpack", params);
  };

  // å‘é€è´­ä¹°å’¸é±¼å¸è®¢å•
  const sendChargeCreateOrder = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "charge_createorder", params);
  };

  // å‘é€å®åº“Bossæˆ˜æ–—
  const sendBossTowerStartBoss = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_startboss", params);
  };

  // å‘é€è·å–å®åº“ä¿¡æ¯
  const sendBossTowerGetInfo = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_getinfo", params);
  };

  // å‘é€æœç´¢å®åº“é˜Ÿä¼
  const sendBossTowerSearchTeam = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_searchteam", params);
  };

  // å‘é€é¢†å–å®åº“å¥–åŠ±
  const sendBossTowerClaimReward = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_claimreward", params);
  };

  // å‘é€å®åº“ä½¿ç”¨é’¥åŒ™
  const sendBossTowerStartBox = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_startbox", params);
  };

  // å‘é€å®åº“ä½¿ç”¨boom
  const sendBossTowerBoom = (tokenId: string, params = {}) => {
    return sendMessageWithPromise(tokenId, "bosstower_boom", params);
  };

  // å‘é€è‡ªå®šä¹‰æ¸¸æˆæ¶ˆæ¯
  const sendGameMessage = (
    tokenId: string,
    cmd: string,
    params = {},
    options = {},
  ) => {
    if (options.usePromise) {
      return sendMessageWithPromise(tokenId, cmd, params, options.timeout);
    } else {
      return sendMessage(tokenId, cmd, params, options);
    }
  };

  // è·å–å½“å‰å¡”å±‚æ•°
  const getCurrentTowerLevel = () => {
    try {
      // ä»æ¸¸æˆæ•°æ®ä¸­è·å–å¡”ä¿¡æ¯
      const roleInfo = gameData.value.roleInfo;
      if (!roleInfo || !roleInfo.role) {
        gameLogger.warn("è§’è‰²ä¿¡æ¯ä¸å­˜åœ¨");
        return null;
      }

      const tower = roleInfo.role.tower;
      if (!tower) {
        gameLogger.warn("å¡”ä¿¡æ¯ä¸å­˜åœ¨");
        return null;
      }

      // å¯èƒ½çš„å¡”å±‚æ•°å­—æ®µï¼ˆæ ¹æ®å®é™…æ•°æ®ç»“æ„è°ƒæ•´ï¼‰
      const level =
        tower.level || tower.currentLevel || tower.floor || tower.stage;

      // å½“å‰å¡”å±‚æ•°
      return level;
    } catch (error) {
      gameLogger.error("è·å–å¡”å±‚æ•°å¤±è´¥:", error);
      return null;
    }
  };

  // è·å–è¯¦ç»†å¡”ä¿¡æ¯
  const getTowerInfo = () => {
    try {
      const roleInfo = gameData.value.roleInfo;
      if (!roleInfo || !roleInfo.role) {
        return null;
      }

      return roleInfo.role.tower || null;
    } catch (error) {
      gameLogger.error("è·å–å¡”ä¿¡æ¯å¤±è´¥:", error);
      return null;
    }
  };

  // å·¥å…·æ–¹æ³•
  const exportTokens = () => {
    return {
      tokens: gameTokens.value,
      exportedAt: new Date().toISOString(),
      version: "2.0",
    };
  };

  const importTokens = (data: any) => {
    try {
      if (data.tokens && Array.isArray(data.tokens)) {
        gameTokens.value = data.tokens;
        return {
          success: true,
          message: `æˆåŠŸå¯¼å…¥ ${data.tokens.length} ä¸ªToken`,
        };
      } else {
        return { success: false, message: "å¯¼å…¥æ•°æ®æ ¼å¼é”™è¯¯" };
      }
    } catch (error) {
      return { success: false, message: "å¯¼å…¥å¤±è´¥ï¼š" + error.message };
    }
  };

  const clearAllTokens = () => {
    // å…³é—­æ‰€æœ‰WebSocketè¿æ¥
    Object.keys(wsConnections.value).forEach((tokenId) => {
      closeWebSocketConnection(tokenId);
    });

    gameTokens.value = [];
    selectedTokenId.value = null;
  };

  const cleanExpiredTokens = () => {
    const now = new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const cleanedTokens = gameTokens.value.filter((token) => {
      // URLå’Œbinæ–‡ä»¶å¯¼å…¥çš„tokenè®¾ä¸ºé•¿æœŸæœ‰æ•ˆï¼Œä¸ä¼šè¿‡æœŸ
      // å‡çº§ä¸ºé•¿æœŸæœ‰æ•ˆçš„tokenä¹Ÿä¸ä¼šè¿‡æœŸ
      if (token.importMethod === "url" || token.importMethod === "bin" || token.upgradedToPermanent) {
        return true;
      }
      // æ‰‹åŠ¨å¯¼å…¥çš„tokenæŒ‰åŸé€»è¾‘å¤„ç†ï¼ˆ24å°æ—¶è¿‡æœŸï¼‰
      const lastUsed = new Date(token.lastUsed || token.createdAt);
      return lastUsed > oneDayAgo;
    });
    const cleanedCount = gameTokens.value.length - cleanedTokens.length;
    gameTokens.value = cleanedTokens;
    return cleanedCount;
  };

  // å°†ç°æœ‰tokenå‡çº§ä¸ºé•¿æœŸæœ‰æ•ˆ
  const upgradeTokenToPermanent = (tokenId: string) => {
    const token = gameTokens.value.find((t) => t.id === tokenId);
    if (token && !token.upgradedToPermanent && token.importMethod !== "url" && token.importMethod !== "bin") {
      updateToken(tokenId, {
        upgradedToPermanent: true,
        upgradedAt: new Date().toISOString(),
      });
      return true;
    }
    return false;
  };

  // è¿æ¥å”¯ä¸€æ€§éªŒè¯å’Œç›‘æ§
  const validateConnectionUniqueness = (tokenId: string) => {
    const connections = Object.values(wsConnections.value).filter(
      (conn) =>
        conn.tokenId === tokenId &&
        (conn.status === "connecting" || conn.status === "connected"),
    );

    if (connections.length > 1) {
      wsLogger.warn(
        `æ£€æµ‹åˆ°é‡å¤è¿æ¥: ${tokenId}, è¿æ¥æ•°: ${connections.length}`,
      );
      // ä¿ç•™æœ€æ–°çš„è¿æ¥ï¼Œå…³é—­æ—§è¿æ¥
      const sortedConnections = connections.sort(
        (a, b) => new Date(b.connectedAt || 0) - new Date(a.connectedAt || 0),
      );

      for (let i = 1; i < sortedConnections.length; i++) {
        const oldConnection = sortedConnections[i];
        wsLogger.debug(`å…³é—­é‡å¤è¿æ¥: ${tokenId}`);
        closeWebSocketConnectionAsync(oldConnection.tokenId);
      }

      return false; // æ£€æµ‹åˆ°é‡å¤è¿æ¥
    }

    return true; // è¿æ¥å”¯ä¸€
  };

  // è¿æ¥ç›‘æ§å’Œæ¸…ç†
  const connectionMonitor = {
    // å®šæœŸæ£€æŸ¥è¿æ¥çŠ¶æ€
    startMonitoring: () => {
      setInterval(() => {
        const now = Date.now();

        console.log("wsè¿æ¥ç›‘æ§è¿è¡Œä¸­...", wsConnections.value);
        console.log("coè¿æ¥ç›‘æ§è¿è¡Œä¸­...", connectionLocks.value);
        console.log("acè¿æ¥ç›‘æ§è¿è¡Œä¸­...", activeConnections.value);

        // æ£€æŸ¥è¿æ¥è¶…æ—¶ï¼ˆè¶…è¿‡30ç§’æœªæ´»åŠ¨ï¼‰
        Object.entries(wsConnections.value).forEach(([tokenId, connection]) => {
          const lastActivity =
            connection.lastMessage?.timestamp || connection.connectedAt;
          if (lastActivity) {
            const timeSinceActivity = now - new Date(lastActivity).getTime();
            if (
              timeSinceActivity > 30000 &&
              connection.status === "connected"
            ) {
              wsLogger.warn(`æ£€æµ‹åˆ°è¿æ¥å¯èƒ½å·²æ–­å¼€: ${tokenId}`);
              // å‘é€å¿ƒè·³æ£€æµ‹
              if (connection.client) {
                connection.client.sendHeartbeat();
              }
            }
          }
        });

        // æ¸…ç†è¿‡æœŸçš„è¿æ¥é”ï¼ˆè¶…è¿‡10åˆ†é’Ÿï¼‰
        Object.entries(connectionLocks.value).forEach(([tokenId, lock]) => {
          if (now - lock.timestamp > 600000) {
            delete connectionLocks.value[tokenId];
            wsLogger.debug(`æ¸…ç†è¿‡æœŸè¿æ¥é”: ${tokenId}`);
          }
        });

        // æ¸…ç†è¿‡æœŸçš„è·¨æ ‡ç­¾é¡µçŠ¶æ€ï¼ˆè¶…è¿‡5åˆ†é’Ÿï¼‰
        Object.entries(activeConnections.value).forEach(([tokenId, state]) => {
          if (now - state.timestamp > 300000) {
            wsLogger.debug(`æ¸…ç†è¿‡æœŸè·¨æ ‡ç­¾é¡µçŠ¶æ€: ${tokenId}`);
            delete activeConnections.value[tokenId];
            localStorage.removeItem(`ws_connection_${tokenId}`);
          }
        });
      }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
    },

    // è·å–è¿æ¥ç»Ÿè®¡ä¿¡æ¯
    getStats: () => {
      const duplicateTokens: string[] = [];
      const stats = {
        totalConnections: Object.keys(wsConnections.value).length,
        connectedCount: 0,
        connectingCount: 0,
        disconnectedCount: 0,
        errorCount: 0,
        duplicateTokens,
        activeLocks: Object.keys(connectionLocks.value).length,
        crossTabStates: Object.keys(activeConnections.value).length,
      };

      // ç»Ÿè®¡è¿æ¥çŠ¶æ€
      const tokenCounts = new Map();
      Object.values(wsConnections.value).forEach((connection) => {
        stats[connection.status + "Count"]++;

        // æ£€æµ‹é‡å¤token
        const count = tokenCounts.get(connection.tokenId) || 0;
        tokenCounts.set(connection.tokenId, count + 1);

        if (count > 0) {
          stats.duplicateTokens.push(connection.tokenId);
        }
      });

      return stats;
    },

    // å¼ºåˆ¶æ¸…ç†æ‰€æœ‰è¿æ¥
    forceCleanup: async () => {
      wsLogger.info("å¼€å§‹å¼ºåˆ¶æ¸…ç†æ‰€æœ‰è¿æ¥...");

      const cleanupPromises = Object.keys(wsConnections.value).map((tokenId) =>
        closeWebSocketConnectionAsync(tokenId),
      );

      await Promise.all(cleanupPromises);

      // TODO:
      // æ¸…ç†æ‰€æœ‰é”å’ŒçŠ¶æ€
      // connectionLocks.value.clear()
      // activeConnections.value.clear()

      // æ¸…ç†localStorageä¸­çš„è·¨æ ‡ç­¾é¡µçŠ¶æ€
      Object.keys(localStorage).forEach((key) => {
        if (key.startsWith("ws_connection_")) {
          localStorage.removeItem(key);
        }
      });

      wsLogger.info("å¼ºåˆ¶æ¸…ç†å®Œæˆ");
    },
  };

  // ç›‘å¬localStorageå˜åŒ–ï¼ˆè·¨æ ‡ç­¾é¡µé€šä¿¡ï¼‰
  const setupCrossTabListener = () => {
    window.addEventListener("storage", (event) => {
      if (event.key?.startsWith("ws_connection_")) {
        const tokenId = event.key.replace("ws_connection_", "");
        wsLogger.debug(
          `æ£€æµ‹åˆ°è·¨æ ‡ç­¾é¡µè¿æ¥çŠ¶æ€å˜åŒ–: ${tokenId}`,
          event.newValue,
        );

        // å¦‚æœå…¶ä»–æ ‡ç­¾é¡µå»ºç«‹äº†è¿æ¥ï¼Œè€ƒè™‘å…³é—­æœ¬æ ‡ç­¾é¡µçš„è¿æ¥
        if (event.newValue) {
          try {
            const newState = JSON.parse(event.newValue);
            const localConnection = wsConnections.value[tokenId];

            if (
              newState.action === "connected" &&
              newState.sessionId !== currentSessionId &&
              localConnection?.status === "connected"
            ) {
              wsLogger.info(
                `æ£€æµ‹åˆ°å…¶ä»–æ ‡ç­¾é¡µå·²è¿æ¥åŒä¸€tokenï¼Œå…³é—­æœ¬åœ°è¿æ¥: ${tokenId}`,
              );
              closeWebSocketConnectionAsync(tokenId);
            }
          } catch (error) {
            wsLogger.warn("è§£æè·¨æ ‡ç­¾é¡µçŠ¶æ€å¤±è´¥:", error);
          }
        }
      }
    });
  };

  // å¤„ç†è¿æ¥é˜Ÿåˆ—
  const processConnectionQueue = async () => {
    // å¦‚æœå½“å‰æ´»è·ƒè¿æ¥æ•°å·²ç»è¾¾åˆ°æœ€å¤§å€¼ï¼Œæˆ–è€…é˜Ÿåˆ—ä¸ºç©ºï¼Œç›´æ¥è¿”å›
    if (activeConnectionCount.value >= maxConcurrentConnections.value || connectionQueue.value.length === 0) {
      return;
    }

    // ä»é˜Ÿåˆ—ä¸­å–å‡ºç¬¬ä¸€ä¸ªtoken
    const tokenId = connectionQueue.value.shift();
    if (!tokenId) return;

    // æ›´æ–°é˜Ÿåˆ—ä½ç½®
    updateConnectionQueuePositions();

    try {
      // æŸ¥æ‰¾å¯¹åº”çš„token
      const token = gameTokens.value.find(t => t.id === tokenId);
      if (!token) {
        wsLogger.error(`Token not found: ${tokenId}`);
        return;
      }

      // å¢åŠ æ´»è·ƒè¿æ¥æ•°
      activeConnectionCount.value++;
      wsLogger.info(`å¼€å§‹å¤„ç†é˜Ÿåˆ—ä¸­çš„è¿æ¥: ${tokenId}ï¼Œå½“å‰æ´»è·ƒè¿æ¥æ•°: ${activeConnectionCount.value}`);

      // åˆ›å»ºè¿æ¥
      await createWebSocketConnectionInternal(tokenId, token.token, token.wsUrl);
    } catch (error) {
      wsLogger.error(`å¤„ç†é˜Ÿåˆ—è¿æ¥å¤±è´¥: ${tokenId}`, error);
    } finally {
      // å‡å°‘æ´»è·ƒè¿æ¥æ•°
      activeConnectionCount.value--;
      wsLogger.info(`é˜Ÿåˆ—è¿æ¥å¤„ç†å®Œæˆ: ${tokenId}ï¼Œå½“å‰æ´»è·ƒè¿æ¥æ•°: ${activeConnectionCount.value}`);

      // å»¶è¿Ÿåç»§ç»­å¤„ç†é˜Ÿåˆ—
      setTimeout(processConnectionQueue, connectionDelay.value);
    }
  };

  // æ›´æ–°è¿æ¥é˜Ÿåˆ—ä½ç½®
  const updateConnectionQueuePositions = () => {
    const newPositions: Record<string, number> = {};
    connectionQueue.value.forEach((tokenId, index) => {
      newPositions[tokenId] = index;
    });
    connectionQueuePositions.value = newPositions;
  };

  // å°†è¿æ¥è¯·æ±‚åŠ å…¥é˜Ÿåˆ—
  const enqueueConnection = (tokenId: string) => {
    // å¦‚æœtokenå·²ç»åœ¨é˜Ÿåˆ—ä¸­ï¼Œä¸é‡å¤æ·»åŠ 
    if (connectionQueue.value.includes(tokenId)) {
      wsLogger.debug(`Token already in queue: ${tokenId}`);
      return;
    }

    // å¦‚æœtokenå·²ç»è¿æ¥æˆ–æ­£åœ¨è¿æ¥ï¼Œä¸åŠ å…¥é˜Ÿåˆ—
    const connection = wsConnections.value[tokenId];
    if (connection && (connection.status === "connected" || connection.status === "connecting")) {
      wsLogger.debug(`Token already connected or connecting: ${tokenId}`);
      return;
    }

    // æ·»åŠ åˆ°é˜Ÿåˆ—
    connectionQueue.value.push(tokenId);
    connectionQueueTimestamps.value[tokenId] = Date.now();
    updateConnectionQueuePositions();

    const position = connectionQueuePositions.value[tokenId];
    const waitTime = getEstimatedWaitTime(tokenId);
    wsLogger.info(`Token added to connection queue: ${tokenId}, position: ${position + 1}, estimated wait: ${waitTime}ms`);

    // è§¦å‘é˜Ÿåˆ—å¤„ç†
    setTimeout(processConnectionQueue, 0);
  };

  // ä»é˜Ÿåˆ—ä¸­ç§»é™¤token
  const dequeueConnection = (tokenId: string) => {
    const index = connectionQueue.value.indexOf(tokenId);
    if (index > -1) {
      connectionQueue.value.splice(index, 1);
      delete connectionQueueTimestamps.value[tokenId];
      updateConnectionQueuePositions();
      wsLogger.info(`Token removed from connection queue: ${tokenId}`);
    }
  };

  // æ ‡è®°ä»»åŠ¡å¼€å§‹
  const startTask = () => {
    runningTasksCount.value++;
    isTasksRunning.value = true;
    wsLogger.info(`ä»»åŠ¡å¼€å§‹ï¼Œå½“å‰è¿è¡Œä»»åŠ¡æ•°: ${runningTasksCount.value}`);
  };

  // æ ‡è®°ä»»åŠ¡ç»“æŸ
  const finishTask = () => {
    runningTasksCount.value = Math.max(0, runningTasksCount.value - 1);
    wsLogger.info(`ä»»åŠ¡ç»“æŸï¼Œå½“å‰è¿è¡Œä»»åŠ¡æ•°: ${runningTasksCount.value}`);

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
    if (runningTasksCount.value === 0 && scheduledTasksQueue.value === 0) {
      isTasksRunning.value = false;
      wsLogger.info(`æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæˆ`);

      // å¦‚æœéœ€è¦ï¼Œå…³é—­æ‰€æœ‰è¿æ¥
      if (shouldCloseConnectionsAfterTasks.value) {
        closeAllConnections();
        shouldCloseConnectionsAfterTasks.value = false;
      }
    }
  };

  // æ ‡è®°å®šæ—¶ä»»åŠ¡æ’é˜Ÿ
  const scheduleTask = () => {
    scheduledTasksQueue.value++;
    isTasksRunning.value = true;
    wsLogger.info(`å®šæ—¶ä»»åŠ¡æ’é˜Ÿï¼Œå½“å‰æ’é˜Ÿæ•°: ${scheduledTasksQueue.value}`);
  };

  // æ ‡è®°å®šæ—¶ä»»åŠ¡å®Œæˆ
  const finishScheduledTask = () => {
    scheduledTasksQueue.value = Math.max(0, scheduledTasksQueue.value - 1);
    wsLogger.info(`å®šæ—¶ä»»åŠ¡å®Œæˆï¼Œå½“å‰æ’é˜Ÿæ•°: ${scheduledTasksQueue.value}`);

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰ä»»åŠ¡éƒ½å·²å®Œæˆ
    if (runningTasksCount.value === 0 && scheduledTasksQueue.value === 0) {
      isTasksRunning.value = false;
      wsLogger.info(`æ‰€æœ‰å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ`);

      // å¦‚æœéœ€è¦ï¼Œå…³é—­æ‰€æœ‰è¿æ¥
      if (shouldCloseConnectionsAfterTasks.value) {
        closeAllConnections();
        shouldCloseConnectionsAfterTasks.value = false;
      }
    }
  };

  // å…³é—­æ‰€æœ‰WebSocketè¿æ¥
  const closeAllConnections = async () => {
    wsLogger.info(`å¼€å§‹å…³é—­æ‰€æœ‰WebSocketè¿æ¥`);

    // æ¸…ç©ºè¿æ¥é˜Ÿåˆ—
    connectionQueue.value = [];
    updateConnectionQueuePositions();

    // å…³é—­æ‰€æœ‰è¿æ¥
    const connectionIds = Object.keys(wsConnections.value);
    wsLogger.info(`éœ€è¦å…³é—­çš„è¿æ¥æ•°: ${connectionIds.length}`);

    // é€ä¸ªå…³é—­è¿æ¥
    for (const tokenId of connectionIds) {
      try {
        await closeWebSocketConnectionAsync(tokenId);
        wsLogger.info(`è¿æ¥å·²å…³é—­: ${tokenId}`);
      } catch (error) {
        wsLogger.error(`å…³é—­è¿æ¥å¤±è´¥: ${tokenId}`, error);
      }
    }

    wsLogger.info(`æ‰€æœ‰WebSocketè¿æ¥å…³é—­å®Œæˆ`);
  };

  // æ ‡è®°ä»»åŠ¡å®Œæˆåå…³é—­è¿æ¥
  const closeAllConnectionsAfterTasks = () => {
    shouldCloseConnectionsAfterTasks.value = true;
    wsLogger.info(`å·²æ ‡è®°ï¼šæ‰€æœ‰ä»»åŠ¡å®Œæˆåå…³é—­è¿æ¥`);

    // å¦‚æœå½“å‰æ²¡æœ‰ä»»åŠ¡æ­£åœ¨æ‰§è¡Œï¼Œç«‹å³å…³é—­è¿æ¥
    if (!isTasksRunning.value) {
      closeAllConnections();
      shouldCloseConnectionsAfterTasks.value = false;
    }
  };

  // åˆå§‹åŒ–
  const initTokenStore = () => {
    // æ¸…ç†è¿‡æœŸtoken
    cleanExpiredTokens();
    // å¯åŠ¨è¿æ¥ç›‘æ§
    connectionMonitor.startMonitoring();

    // è®¾ç½®è·¨æ ‡ç­¾é¡µç›‘å¬
    setupCrossTabListener();
    tokenLogger.info("Token Store åˆå§‹åŒ–å®Œæˆï¼Œè¿æ¥ç›‘æ§å·²å¯åŠ¨");
  };
  const setBattleVersion = (version: number | null) => {
    gameData.value.battleVersion = version;
    gameData.value.lastUpdated = new Date().toISOString();
  };

  const getBattleVersion = () => {
    return gameData.value.battleVersion;
  };

  return {
    // çŠ¶æ€
    gameTokens,
    selectedTokenId,
    wsConnections,
    gameData,

    // è®¡ç®—å±æ€§
    hasTokens,
    selectedToken,
    selectedTokenRoleInfo,

    // è¿æ¥é™æµç›¸å…³çŠ¶æ€
    connectionQueue,
    activeConnectionCount,
    maxConcurrentConnections,
    queuedTokens,

    // Tokenç®¡ç†æ–¹æ³•
    addToken,
    updateToken,
    removeToken,
    selectToken,

    // Base64è§£ææ–¹æ³•
    parseBase64Token,
    importBase64Token,

    // WebSocketæ–¹æ³•
    createWebSocketConnection,
    connectWebSocket,
    disconnectWebSocket,
    closeWebSocketConnection,
    getWebSocketStatus,
    getWebSocketClient,
    sendMessage,
    sendMessageWithPromise,
    setMessageListener,
    setShowMsg,
    sendHeartbeat,
    sendGetRoleInfo,
    sendGetDataBundleVersion,
    sendSignIn,
    sendClaimDailyReward,
    sendGetTeamInfo,
    sendLegionStoreBuyGoods,
    sendCollectionClaimFreeReward,
    sendLegacyClaimHangup,
    sendLegacyClaimGift,
    sendRoleCommitPassword,
    sendLegacySendGift,
    sendLegacyGetGifts,
    sendLegacyGetInfo,
    sendLegacyActivate,
    sendLegionGetInfo,
    sendNightmareGetRoleInfo,
    sendNightmareClickTurntable,
    sendNightmareClaimTurnRewardTimes,
    sendNightmareFight,
    sendNightmareSetFighter,
    sendNightmareRestore,
    sendNightmareClaimBook,
    sendNightmareClaimWeekReward,
    sendMatchteamGetRoleTeamInfo,
    sendMatchteamKick,
    sendMatchteamOpenTeam,
    sendMatchteamLeave,
    sendPresetteamSaveTeam,
    sendPresetteamGetInfo,
    sendFightStartGenie,
    sendFightStartLevel,
    sendHeroExchange,
    sendHeroCalcpowerbyteam,
    sendGenieSweep,
    sendLegionExchangeResearch,
    sendLegionResearch,
    sendLegionResetResearch,
    sendStoreGetPurchase,
    sendItemClaimBoxPointReward,
    sendActivityClaimTaskReward,
    sendActivityGetActeGameInfo,
    sendActivityActeGameStageClaim,
    sendActivityStarteGame,
    sendActivityCommonBuyGoods,
    sendActivityMaydaylottery,
    sendMergeboxClaimMergeProgress,
    sendMergeboxClaimCostProgress,
    sendEvotowerClaimTask,
    sendEvotowerClaimLegionPrivilege,
    sendMergeboxMergeItem,
    sendMergeboxOpenBox,
    sendTowersStart,
    sendTowersFight,
    sendTowersGetInfo,
    sendMailClaimAllAttachment,
    sendItemOpenPack,
    sendChargeCreateOrder,
    sendBossTowerStartBoss,
    sendBossTowerGetInfo,
    sendBossTowerSearchTeam,
    sendBossTowerClaimReward,
    sendBossTowerStartBox,
    sendBossTowerBoom,
    sendGameMessage,

    // è¿æ¥é™æµç›¸å…³æ–¹æ³•
    getEstimatedWaitTime,
    enqueueConnection,
    dequeueConnection,
    processConnectionQueue,

    // ä»»åŠ¡æ‰§è¡Œç®¡ç†æ–¹æ³•
    startTask,
    finishTask,
    scheduleTask,
    finishScheduledTask,
    closeAllConnections,
    closeAllConnectionsAfterTasks,

    // ä»»åŠ¡çŠ¶æ€
    runningTasksCount,
    scheduledTasksQueue,
    isTasksRunning,

    // å·¥å…·æ–¹æ³•
    exportTokens,
    importTokens,
    clearAllTokens,
    cleanExpiredTokens,
    upgradeTokenToPermanent,
    initTokenStore,

    // å¡”ä¿¡æ¯æ–¹æ³•
    getCurrentTowerLevel,
    getTowerInfo,

    // battleVersion
    setBattleVersion,
    getBattleVersion,

    // è°ƒè¯•å·¥å…·æ–¹æ³•
    validateToken,
    debugToken: (tokenString: string) => {
      console.log("ğŸ” Tokenè°ƒè¯•ä¿¡æ¯:");
      console.log("åŸå§‹Token:", tokenString);
      const parseResult = parseBase64Token(tokenString);
      console.log("è§£æç»“æœ:", parseResult);
      if (parseResult.success) {
        console.log("å®é™…Token:", parseResult.data.actualToken);
        console.log(
          "Tokenæœ‰æ•ˆæ€§:",
          validateToken(parseResult.data.actualToken),
        );
      }
      return parseResult;
    },

    // è¿æ¥ç®¡ç†å¢å¼ºåŠŸèƒ½
    validateConnectionUniqueness,
    connectionMonitor,
    currentSessionId: () => currentSessionId,

    // å¼€å‘è€…å·¥å…·
    devTools: {
      getConnectionStats: () => connectionMonitor.getStats(),
      forceCleanup: () => connectionMonitor.forceCleanup(),
      showConnectionLocks: () => Object.keys(connectionLocks.value),
      showCrossTabStates: () => Object.keys(activeConnections.value),
      testDuplicateConnection: (tokenId: string) => {
        // é™å™ª
        const token = gameTokens.value.find((t) => t.id === tokenId);
        if (token) {
          // æ•…æ„åˆ›å»ºç¬¬äºŒä¸ªè¿æ¥è¿›è¡Œæµ‹è¯•
          createWebSocketConnection(tokenId + "_test", token.token);
        }
      },
    },
  };
});
